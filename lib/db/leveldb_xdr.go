// ************************************************************
// This file is automatically generated by genxdr. Do not edit.
// ************************************************************

package db

import (
	"github.com/calmh/xdr"
)

/*

fileVersion Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                       Vector Structure                        \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           device ID                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct fileVersion {
	Vector version;
	unsigned int deviceID;
}

*/

func (o fileVersion) XDRSize() int {
	return o.version.XDRSize() + 4
}

func (o fileVersion) MarshalXDR() ([]byte, error) {
	buf := make([]byte, o.XDRSize())
	m := &xdr.Marshaller{Data: buf}
	return buf, o.MarshalXDRInto(m)
}

func (o fileVersion) MustMarshalXDR() []byte {
	bs, err := o.MarshalXDR()
	if err != nil {
		panic(err)
	}
	return bs
}

func (o fileVersion) MarshalXDRInto(m *xdr.Marshaller) error {
	if err := o.version.MarshalXDRInto(m); err != nil {
		return err
	}
	m.MarshalUint32(o.deviceID)
	return m.Error
}

func (o *fileVersion) UnmarshalXDR(bs []byte) error {
	u := &xdr.Unmarshaller{Data: bs}
	return o.UnmarshalXDRFrom(u)
}
func (o *fileVersion) UnmarshalXDRFrom(u *xdr.Unmarshaller) error {
	(&o.version).UnmarshalXDRFrom(u)
	o.deviceID = u.UnmarshalUint32()
	return u.Error
}

/*

versionList Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Number of versions                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\              Zero or more fileVersion Structures              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct versionList {
	fileVersion versions<>;
}

*/

func (o versionList) XDRSize() int {
	return 4 + xdr.SizeOfSlice(o.versions)
}

func (o versionList) MarshalXDR() ([]byte, error) {
	buf := make([]byte, o.XDRSize())
	m := &xdr.Marshaller{Data: buf}
	return buf, o.MarshalXDRInto(m)
}

func (o versionList) MustMarshalXDR() []byte {
	bs, err := o.MarshalXDR()
	if err != nil {
		panic(err)
	}
	return bs
}

func (o versionList) MarshalXDRInto(m *xdr.Marshaller) error {
	m.MarshalUint32(uint32(len(o.versions)))
	for i := range o.versions {
		if err := o.versions[i].MarshalXDRInto(m); err != nil {
			return err
		}
	}
	return m.Error
}

func (o *versionList) UnmarshalXDR(bs []byte) error {
	u := &xdr.Unmarshaller{Data: bs}
	return o.UnmarshalXDRFrom(u)
}
func (o *versionList) UnmarshalXDRFrom(u *xdr.Unmarshaller) error {
	_versionsSize := int(u.UnmarshalUint32())
	if _versionsSize < 0 {
		return xdr.ElementSizeExceeded("versions", _versionsSize, 0)
	} else if _versionsSize == 0 {
		o.versions = nil
	} else {
		if _versionsSize <= len(o.versions) {
			o.versions = o.versions[:_versionsSize]
		} else {
			o.versions = make([]fileVersion, _versionsSize)
		}
		for i := range o.versions {
			(&o.versions[i]).UnmarshalXDRFrom(u)
		}
	}
	return u.Error
}

/*

oldFileVersion Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                       Vector Structure                        \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                 device (length + padded data)                 \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct oldFileVersion {
	Vector version;
	opaque device<>;
}

*/

func (o oldFileVersion) XDRSize() int {
	return o.version.XDRSize() +
		4 + len(o.device) + xdr.Padding(len(o.device))
}

func (o oldFileVersion) MarshalXDR() ([]byte, error) {
	buf := make([]byte, o.XDRSize())
	m := &xdr.Marshaller{Data: buf}
	return buf, o.MarshalXDRInto(m)
}

func (o oldFileVersion) MustMarshalXDR() []byte {
	bs, err := o.MarshalXDR()
	if err != nil {
		panic(err)
	}
	return bs
}

func (o oldFileVersion) MarshalXDRInto(m *xdr.Marshaller) error {
	if err := o.version.MarshalXDRInto(m); err != nil {
		return err
	}
	m.MarshalBytes(o.device)
	return m.Error
}

func (o *oldFileVersion) UnmarshalXDR(bs []byte) error {
	u := &xdr.Unmarshaller{Data: bs}
	return o.UnmarshalXDRFrom(u)
}
func (o *oldFileVersion) UnmarshalXDRFrom(u *xdr.Unmarshaller) error {
	(&o.version).UnmarshalXDRFrom(u)
	o.device = u.UnmarshalBytes()
	return u.Error
}

/*

oldVersionList Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Number of versions                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\            Zero or more oldFileVersion Structures             \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct oldVersionList {
	oldFileVersion versions<>;
}

*/

func (o oldVersionList) XDRSize() int {
	return 4 + xdr.SizeOfSlice(o.versions)
}

func (o oldVersionList) MarshalXDR() ([]byte, error) {
	buf := make([]byte, o.XDRSize())
	m := &xdr.Marshaller{Data: buf}
	return buf, o.MarshalXDRInto(m)
}

func (o oldVersionList) MustMarshalXDR() []byte {
	bs, err := o.MarshalXDR()
	if err != nil {
		panic(err)
	}
	return bs
}

func (o oldVersionList) MarshalXDRInto(m *xdr.Marshaller) error {
	m.MarshalUint32(uint32(len(o.versions)))
	for i := range o.versions {
		if err := o.versions[i].MarshalXDRInto(m); err != nil {
			return err
		}
	}
	return m.Error
}

func (o *oldVersionList) UnmarshalXDR(bs []byte) error {
	u := &xdr.Unmarshaller{Data: bs}
	return o.UnmarshalXDRFrom(u)
}
func (o *oldVersionList) UnmarshalXDRFrom(u *xdr.Unmarshaller) error {
	_versionsSize := int(u.UnmarshalUint32())
	if _versionsSize < 0 {
		return xdr.ElementSizeExceeded("versions", _versionsSize, 0)
	} else if _versionsSize == 0 {
		o.versions = nil
	} else {
		if _versionsSize <= len(o.versions) {
			o.versions = o.versions[:_versionsSize]
		} else {
			o.versions = make([]oldFileVersion, _versionsSize)
		}
		for i := range o.versions {
			(&o.versions[i]).UnmarshalXDRFrom(u)
		}
	}
	return u.Error
}

/*

blockmapList Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Number of locations                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\           Zero or more blockmapLocation Structures            \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct blockmapList {
	blockmapLocation locations<>;
}

*/

func (o blockmapList) XDRSize() int {
	return 4 + xdr.SizeOfSlice(o.locations)
}

func (o blockmapList) MarshalXDR() ([]byte, error) {
	buf := make([]byte, o.XDRSize())
	m := &xdr.Marshaller{Data: buf}
	return buf, o.MarshalXDRInto(m)
}

func (o blockmapList) MustMarshalXDR() []byte {
	bs, err := o.MarshalXDR()
	if err != nil {
		panic(err)
	}
	return bs
}

func (o blockmapList) MarshalXDRInto(m *xdr.Marshaller) error {
	m.MarshalUint32(uint32(len(o.locations)))
	for i := range o.locations {
		if err := o.locations[i].MarshalXDRInto(m); err != nil {
			return err
		}
	}
	return m.Error
}

func (o *blockmapList) UnmarshalXDR(bs []byte) error {
	u := &xdr.Unmarshaller{Data: bs}
	return o.UnmarshalXDRFrom(u)
}
func (o *blockmapList) UnmarshalXDRFrom(u *xdr.Unmarshaller) error {
	_locationsSize := int(u.UnmarshalUint32())
	if _locationsSize < 0 {
		return xdr.ElementSizeExceeded("locations", _locationsSize, 0)
	} else if _locationsSize == 0 {
		o.locations = nil
	} else {
		if _locationsSize <= len(o.locations) {
			o.locations = o.locations[:_locationsSize]
		} else {
			o.locations = make([]blockmapLocation, _locationsSize)
		}
		for i := range o.locations {
			(&o.locations[i]).UnmarshalXDRFrom(u)
		}
	}
	return u.Error
}

/*

blockmapLocation Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           folder ID                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       name ID (64 bits)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           block Idx                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct blockmapLocation {
	unsigned int folderID;
	unsigned hyper nameID;
	unsigned int blockIdx;
}

*/

func (o blockmapLocation) XDRSize() int {
	return 4 + 8 + 4
}

func (o blockmapLocation) MarshalXDR() ([]byte, error) {
	buf := make([]byte, o.XDRSize())
	m := &xdr.Marshaller{Data: buf}
	return buf, o.MarshalXDRInto(m)
}

func (o blockmapLocation) MustMarshalXDR() []byte {
	bs, err := o.MarshalXDR()
	if err != nil {
		panic(err)
	}
	return bs
}

func (o blockmapLocation) MarshalXDRInto(m *xdr.Marshaller) error {
	m.MarshalUint32(o.folderID)
	m.MarshalUint64(o.nameID)
	m.MarshalUint32(o.blockIdx)
	return m.Error
}

func (o *blockmapLocation) UnmarshalXDR(bs []byte) error {
	u := &xdr.Unmarshaller{Data: bs}
	return o.UnmarshalXDRFrom(u)
}
func (o *blockmapLocation) UnmarshalXDRFrom(u *xdr.Unmarshaller) error {
	o.folderID = u.UnmarshalUint32()
	o.nameID = u.UnmarshalUint64()
	o.blockIdx = u.UnmarshalUint32()
	return u.Error
}
